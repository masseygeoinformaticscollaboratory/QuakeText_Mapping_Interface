{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    }.bind(this));\n  }\n}\nexport default TileCache;","map":{"version":3,"names":["LRUCache","fromKey","getKey","TileCache","clear","getCount","pop","release","expireCache","usedTiles","canExpireCache","tile","peekLast","pruneExceptNewestZ","key","peekFirstKey","tileCoord","z","forEach","remove","bind"],"sources":["/Users/lydiaprice/quake-text/node_modules/ol/TileCache.js"],"sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(\n      function (tile) {\n        if (tile.tileCoord[0] !== z) {\n          this.remove(getKey(tile.tileCoord));\n          tile.release();\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default TileCache;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,uBAAuB;AAC5C,SAAQC,OAAO,EAAEC,MAAM,QAAO,gBAAgB;AAE9C,MAAMC,SAAS,SAASH,QAAQ,CAAC;EAC/BI,KAAK,GAAG;IACN,OAAO,IAAI,CAACC,QAAQ,EAAE,GAAG,CAAC,EAAE;MAC1B,IAAI,CAACC,GAAG,EAAE,CAACC,OAAO,EAAE;IACtB;IACA,KAAK,CAACH,KAAK,EAAE;EACf;;EAEA;AACF;AACA;EACEI,WAAW,CAACC,SAAS,EAAE;IACrB,OAAO,IAAI,CAACC,cAAc,EAAE,EAAE;MAC5B,MAAMC,IAAI,GAAG,IAAI,CAACC,QAAQ,EAAE;MAC5B,IAAID,IAAI,CAACT,MAAM,EAAE,IAAIO,SAAS,EAAE;QAC9B;MACF,CAAC,MAAM;QACL,IAAI,CAACH,GAAG,EAAE,CAACC,OAAO,EAAE;MACtB;IACF;EACF;;EAEA;AACF;AACA;EACEM,kBAAkB,GAAG;IACnB,IAAI,IAAI,CAACR,QAAQ,EAAE,KAAK,CAAC,EAAE;MACzB;IACF;IACA,MAAMS,GAAG,GAAG,IAAI,CAACC,YAAY,EAAE;IAC/B,MAAMC,SAAS,GAAGf,OAAO,CAACa,GAAG,CAAC;IAC9B,MAAMG,CAAC,GAAGD,SAAS,CAAC,CAAC,CAAC;IACtB,IAAI,CAACE,OAAO,CACV,UAAUP,IAAI,EAAE;MACd,IAAIA,IAAI,CAACK,SAAS,CAAC,CAAC,CAAC,KAAKC,CAAC,EAAE;QAC3B,IAAI,CAACE,MAAM,CAACjB,MAAM,CAACS,IAAI,CAACK,SAAS,CAAC,CAAC;QACnCL,IAAI,CAACJ,OAAO,EAAE;MAChB;IACF,CAAC,CAACa,IAAI,CAAC,IAAI,CAAC,CACb;EACH;AACF;AAEA,eAAejB,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}