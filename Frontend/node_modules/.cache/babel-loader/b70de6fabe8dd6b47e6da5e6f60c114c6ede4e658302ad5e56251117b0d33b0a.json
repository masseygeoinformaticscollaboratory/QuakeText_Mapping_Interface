{"ast":null,"code":"/**\n * @module ol/format/Polyline\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport { assert } from '../asserts.js';\nimport { flipXY } from '../geom/flat/flip.js';\nimport { get as getProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { inflateCoordinates } from '../geom/flat/inflate.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the format reader.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the Encoded\n * Polyline Algorithm Format.\n *\n * When reading features, the coordinates are assumed to be in two dimensions\n * and in [latitude, longitude] order.\n *\n * As Polyline sources contain a single feature,\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\n * feature in an array.\n *\n * @api\n */\nclass Polyline extends TextFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.factor_ = options.factor ? options.factor : 1e5;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geometry = this.readGeometryFromText(text, options);\n    return new Feature(geometry);\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    return [feature];\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const stride = getStrideForLayout(this.geometryLayout_);\n    const flatCoordinates = decodeDeltas(text, stride, this.factor_);\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    const coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n    const lineString = new LineString(coordinates, this.geometryLayout_);\n    return transformGeometryWithOptions(lineString, false, this.adaptOptions(options));\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default<LineString>} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    } else {\n      assert(false, 40); // Expected `feature` to have a geometry\n      return '';\n    }\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default<LineString>>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    return this.writeFeatureText(features[0], options);\n  }\n\n  /**\n   * @param {LineString} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    geometry = /** @type {LineString} */\n\n    transformGeometryWithOptions(geometry, true, this.adaptOptions(options));\n    const flatCoordinates = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\n  }\n}\n\n/**\n * Encode a list of n-dimensional points and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of n-dimensional points.\n * @param {number} stride The number of dimension of the points in the list.\n * @param {number} [factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeDeltas(numbers, stride, factor) {\n  factor = factor ? factor : 1e5;\n  let d;\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n  for (let i = 0, ii = numbers.length; i < ii;) {\n    for (d = 0; d < stride; ++d, ++i) {\n      const num = numbers[i];\n      const delta = num - lastNumbers[d];\n      lastNumbers[d] = num;\n      numbers[i] = delta;\n    }\n  }\n  return encodeFloats(numbers, factor);\n}\n\n/**\n * Decode a list of n-dimensional points from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} stride The number of dimension of the points in the\n *     encoded string.\n * @param {number} [factor] The factor by which the resulting numbers will\n *     be divided. Default is `1e5`.\n * @return {Array<number>} A list of n-dimensional points.\n * @api\n */\nexport function decodeDeltas(encoded, stride, factor) {\n  factor = factor ? factor : 1e5;\n  let d;\n\n  /** @type {Array<number>} */\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n  const numbers = decodeFloats(encoded, factor);\n  for (let i = 0, ii = numbers.length; i < ii;) {\n    for (d = 0; d < stride; ++d, ++i) {\n      lastNumbers[d] += numbers[i];\n      numbers[i] = lastNumbers[d];\n    }\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of floating point numbers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of floating point numbers.\n * @param {number} [factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeFloats(numbers, factor) {\n  factor = factor ? factor : 1e5;\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] = Math.round(numbers[i] * factor);\n  }\n  return encodeSignedIntegers(numbers);\n}\n\n/**\n * Decode a list of floating point numbers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} [factor] The factor by which the result will be divided.\n *     Default is `1e5`.\n * @return {Array<number>} A list of floating point numbers.\n * @api\n */\nexport function decodeFloats(encoded, factor) {\n  factor = factor ? factor : 1e5;\n  const numbers = decodeSignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] /= factor;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of signed integers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of signed integers.\n * @return {string} The encoded string.\n */\nexport function encodeSignedIntegers(numbers) {\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num < 0 ? ~(num << 1) : num << 1;\n  }\n  return encodeUnsignedIntegers(numbers);\n}\n\n/**\n * Decode a list of signed integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of signed integers.\n */\nexport function decodeSignedIntegers(encoded) {\n  const numbers = decodeUnsignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of unsigned integers and return an encoded string\n *\n * @param {Array<number>} numbers A list of unsigned integers.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedIntegers(numbers) {\n  let encoded = '';\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    encoded += encodeUnsignedInteger(numbers[i]);\n  }\n  return encoded;\n}\n\n/**\n * Decode a list of unsigned integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of unsigned integers.\n */\nexport function decodeUnsignedIntegers(encoded) {\n  const numbers = [];\n  let current = 0;\n  let shift = 0;\n  for (let i = 0, ii = encoded.length; i < ii; ++i) {\n    const b = encoded.charCodeAt(i) - 63;\n    current |= (b & 0x1f) << shift;\n    if (b < 0x20) {\n      numbers.push(current);\n      current = 0;\n      shift = 0;\n    } else {\n      shift += 5;\n    }\n  }\n  return numbers;\n}\n\n/**\n * Encode one single unsigned integer and return an encoded string\n *\n * @param {number} num Unsigned integer that should be encoded.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedInteger(num) {\n  let value,\n    encoded = '';\n  while (num >= 0x20) {\n    value = (0x20 | num & 0x1f) + 63;\n    encoded += String.fromCharCode(value);\n    num >>= 5;\n  }\n  value = num + 63;\n  encoded += String.fromCharCode(value);\n  return encoded;\n}\nexport default Polyline;","map":{"version":3,"names":["Feature","LineString","TextFeature","assert","flipXY","get","getProjection","getStrideForLayout","inflateCoordinates","transformGeometryWithOptions","Polyline","constructor","options","dataProjection","factor_","factor","geometryLayout_","geometryLayout","readFeatureFromText","text","geometry","readGeometryFromText","readFeaturesFromText","feature","stride","flatCoordinates","decodeDeltas","length","coordinates","lineString","adaptOptions","writeFeatureText","getGeometry","writeGeometryText","writeFeaturesText","features","getFlatCoordinates","getStride","encodeDeltas","numbers","d","lastNumbers","Array","i","ii","num","delta","encodeFloats","encoded","decodeFloats","Math","round","encodeSignedIntegers","decodeSignedIntegers","encodeUnsignedIntegers","decodeUnsignedIntegers","encodeUnsignedInteger","current","shift","b","charCodeAt","push","value","String","fromCharCode"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/format/Polyline.js"],"sourcesContent":["/**\n * @module ol/format/Polyline\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport {assert} from '../asserts.js';\nimport {flipXY} from '../geom/flat/flip.js';\nimport {get as getProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the format reader.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the Encoded\n * Polyline Algorithm Format.\n *\n * When reading features, the coordinates are assumed to be in two dimensions\n * and in [latitude, longitude] order.\n *\n * As Polyline sources contain a single feature,\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\n * feature in an array.\n *\n * @api\n */\nclass Polyline extends TextFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.factor_ = options.factor ? options.factor : 1e5;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geometry = this.readGeometryFromText(text, options);\n    return new Feature(geometry);\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    return [feature];\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const stride = getStrideForLayout(this.geometryLayout_);\n    const flatCoordinates = decodeDeltas(text, stride, this.factor_);\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    const coordinates = inflateCoordinates(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride\n    );\n    const lineString = new LineString(coordinates, this.geometryLayout_);\n\n    return transformGeometryWithOptions(\n      lineString,\n      false,\n      this.adaptOptions(options)\n    );\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default<LineString>} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    } else {\n      assert(false, 40); // Expected `feature` to have a geometry\n      return '';\n    }\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default<LineString>>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    return this.writeFeatureText(features[0], options);\n  }\n\n  /**\n   * @param {LineString} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    geometry =\n      /** @type {LineString} */\n      (\n        transformGeometryWithOptions(geometry, true, this.adaptOptions(options))\n      );\n    const flatCoordinates = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\n  }\n}\n\n/**\n * Encode a list of n-dimensional points and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of n-dimensional points.\n * @param {number} stride The number of dimension of the points in the list.\n * @param {number} [factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeDeltas(numbers, stride, factor) {\n  factor = factor ? factor : 1e5;\n  let d;\n\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  for (let i = 0, ii = numbers.length; i < ii; ) {\n    for (d = 0; d < stride; ++d, ++i) {\n      const num = numbers[i];\n      const delta = num - lastNumbers[d];\n      lastNumbers[d] = num;\n\n      numbers[i] = delta;\n    }\n  }\n\n  return encodeFloats(numbers, factor);\n}\n\n/**\n * Decode a list of n-dimensional points from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} stride The number of dimension of the points in the\n *     encoded string.\n * @param {number} [factor] The factor by which the resulting numbers will\n *     be divided. Default is `1e5`.\n * @return {Array<number>} A list of n-dimensional points.\n * @api\n */\nexport function decodeDeltas(encoded, stride, factor) {\n  factor = factor ? factor : 1e5;\n  let d;\n\n  /** @type {Array<number>} */\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  const numbers = decodeFloats(encoded, factor);\n\n  for (let i = 0, ii = numbers.length; i < ii; ) {\n    for (d = 0; d < stride; ++d, ++i) {\n      lastNumbers[d] += numbers[i];\n\n      numbers[i] = lastNumbers[d];\n    }\n  }\n\n  return numbers;\n}\n\n/**\n * Encode a list of floating point numbers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of floating point numbers.\n * @param {number} [factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeFloats(numbers, factor) {\n  factor = factor ? factor : 1e5;\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] = Math.round(numbers[i] * factor);\n  }\n\n  return encodeSignedIntegers(numbers);\n}\n\n/**\n * Decode a list of floating point numbers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} [factor] The factor by which the result will be divided.\n *     Default is `1e5`.\n * @return {Array<number>} A list of floating point numbers.\n * @api\n */\nexport function decodeFloats(encoded, factor) {\n  factor = factor ? factor : 1e5;\n  const numbers = decodeSignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] /= factor;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of signed integers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of signed integers.\n * @return {string} The encoded string.\n */\nexport function encodeSignedIntegers(numbers) {\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num < 0 ? ~(num << 1) : num << 1;\n  }\n  return encodeUnsignedIntegers(numbers);\n}\n\n/**\n * Decode a list of signed integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of signed integers.\n */\nexport function decodeSignedIntegers(encoded) {\n  const numbers = decodeUnsignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of unsigned integers and return an encoded string\n *\n * @param {Array<number>} numbers A list of unsigned integers.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedIntegers(numbers) {\n  let encoded = '';\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    encoded += encodeUnsignedInteger(numbers[i]);\n  }\n  return encoded;\n}\n\n/**\n * Decode a list of unsigned integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of unsigned integers.\n */\nexport function decodeUnsignedIntegers(encoded) {\n  const numbers = [];\n  let current = 0;\n  let shift = 0;\n  for (let i = 0, ii = encoded.length; i < ii; ++i) {\n    const b = encoded.charCodeAt(i) - 63;\n    current |= (b & 0x1f) << shift;\n    if (b < 0x20) {\n      numbers.push(current);\n      current = 0;\n      shift = 0;\n    } else {\n      shift += 5;\n    }\n  }\n  return numbers;\n}\n\n/**\n * Encode one single unsigned integer and return an encoded string\n *\n * @param {number} num Unsigned integer that should be encoded.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedInteger(num) {\n  let value,\n    encoded = '';\n  while (num >= 0x20) {\n    value = (0x20 | (num & 0x1f)) + 63;\n    encoded += String.fromCharCode(value);\n    num >>= 5;\n  }\n  value = num + 63;\n  encoded += String.fromCharCode(value);\n  return encoded;\n}\n\nexport default Polyline;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}