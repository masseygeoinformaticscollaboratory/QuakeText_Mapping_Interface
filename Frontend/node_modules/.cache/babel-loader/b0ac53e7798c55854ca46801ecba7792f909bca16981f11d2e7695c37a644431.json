{"ast":null,"code":"/**\n * @module ol/xml\n */\nimport { extend } from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */\n        objectStack[objectStack.length - 1];\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */\n        objectStack[objectStack.length - 1];\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */\n        objectStack[objectStack.length - 1];\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */\n        objectStack[objectStack.length - 1];\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(thisArg !== undefined ? thisArg : this, node, value, objectStack);\n    const parent = /** @type {NodeStackItem} */\n    objectStack[objectStack.length - 1];\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */\n      objectStack[objectStack.length - 1];\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n      const namespaceURI = fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */nodeName);\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return (/** @type {T} */objectStack.pop()\n  );\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(thisArg !== undefined ? thisArg : this, value, objectStack, keys !== undefined ? keys[i] : undefined);\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(thisArg, node, value, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, keys, thisArg) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return (/** @type {O|undefined} */objectStack.pop()\n  );\n}\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}","map":{"version":3,"names":["extend","XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","join","accumulator","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","push","String","nodeValue","replace","n","firstChild","nextSibling","isDocument","object","getAttributeNS","name","parse","xml","DOMParser","parseFromString","makeArrayExtender","valueReader","thisArg","objectStack","value","call","undefined","array","length","makeArrayPusher","makeReplacer","makeObjectPropertyPusher","property","localName","makeObjectPropertySetter","makeChildAppender","nodeWriter","parent","parentNode","appendChild","makeArraySerializer","serializersNS","nodeFactory","serializers","makeSimpleNodeFactory","serialize","fixedNodeName","fixedNamespaceURI","newNodeName","context","nodeName","OBJECT_PROPERTY_NODE_FACTORY","makeSequence","orderedKeys","sequence","Array","i","makeStructureNS","namespaceURIs","structure","structureNS","ii","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","values","keys","pushSerializeAndPop","xmlSerializer_","registerXMLSerializer","xmlSerializer","getXMLSerializer","XMLSerializer","document_","registerDocument","document","implementation","createDocument"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/xml.js"],"sourcesContent":["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      thisArg !== undefined ? thisArg : this,\n      node,\n      value,\n      objectStack\n    );\n    const parent = /** @type {NodeStackItem} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg !== undefined ? thisArg : this,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}