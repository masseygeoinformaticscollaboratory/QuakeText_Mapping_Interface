{"ast":null,"code":"/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE'\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return c >= '0' && c <= '9' || c == '.' && !decimal;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n    return {\n      position: position,\n      value: value,\n      type: type\n    };\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (this.isNumeric_(c, decimal) ||\n    // if we haven't detected a scientific number before, 'e' or 'E'\n    // hint that we should continue to read\n    !scientificNotation && (c == 'e' || c == 'E') ||\n    // once we know that we have a scientific number, both '-' and '+'\n    // are allowed\n    scientificNotation && (c == '-' || c == '+'));\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push( /** @type {number} */token.value);\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */token.value;\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      } else {\n        const ctor = GeometryConstructor[geomType];\n        if (!ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n        let coordinates;\n        if (isEmpty) {\n          if (geomType == 'POINT') {\n            coordinates = [NaN, NaN];\n          } else {\n            coordinates = [];\n          }\n        } else {\n          switch (geomType) {\n            case 'POINT':\n              {\n                coordinates = this.parsePointText_();\n                break;\n              }\n            case 'LINESTRING':\n              {\n                coordinates = this.parseLineStringText_();\n                break;\n              }\n            case 'POLYGON':\n              {\n                coordinates = this.parsePolygonText_();\n                break;\n              }\n            case 'MULTIPOINT':\n              {\n                coordinates = this.parseMultiPointText_();\n                break;\n              }\n            case 'MULTILINESTRING':\n              {\n                coordinates = this.parseMultiLineStringText_();\n                break;\n              }\n            case 'MULTIPOLYGON':\n              {\n                coordinates = this.parseMultiPolygonText_();\n                break;\n              }\n            default:\n              break;\n          }\n        }\n        return new ctor(coordinates, this.layout_);\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof /** @type {?} */geom.getFlatCoordinates === 'function') {\n    const dimInfo = encodeGeometryLayout( /** @type {import(\"../geom/SimpleGeometry.js\").default} */geom);\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\nexport default WKT;","map":{"version":3,"names":["Feature","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","TextFeature","transformGeometryWithOptions","GeometryConstructor","EMPTY","Z","M","ZM","TokenType","START","TEXT","LEFT_PAREN","RIGHT_PAREN","NUMBER","COMMA","EOF","wktTypeLookup","Circle","Lexer","constructor","wkt","index_","isAlpha_","c","isNumeric_","decimal","undefined","isWhiteSpace_","nextChar_","charAt","nextToken","position","value","type","readNumber_","readText_","Error","index","scientificNotation","parseFloat","substring","toUpperCase","Parser","lexer","lexer_","token_","layout_","consume_","isTokenType","match","isMatch","parse","parseGeometry_","parseGeometryLayout_","layout","dimToken","dimInfo","parseGeometryCollectionText_","geometries","push","formatErrorMessage_","parsePointText_","coordinates","parsePoint_","parseLineStringText_","parsePointList_","parsePolygonText_","parseLineStringTextList_","parseMultiPointText_","parsePointTextList_","parseMultiLineStringText_","parseMultiPolygonText_","parsePolygonTextList_","dimensions","length","i","token","isEmptyGeometry_","isEmpty","geomType","ctor","NaN","WKT","options","splitCollection_","splitCollection","parse_","parser","readFeatureFromText","text","geom","readGeometryFromText","feature","setGeometry","readFeaturesFromText","geometry","getType","getGeometriesArray","features","ii","writeFeatureText","getGeometry","writeGeometryText","writeFeaturesText","collection","encode","encodePointGeometry","getCoordinates","join","encodeMultiPointGeometry","array","components","getPoints","encodeGeometryCollectionGeometry","geoms","getGeometries","encodeLineStringGeometry","encodeMultiLineStringGeometry","getLineStrings","encodePolygonGeometry","rings","getLinearRings","encodeMultiPolygonGeometry","getPolygons","encodeGeometryLayout","getLayout","GeometryEncoder","geometryEncoder","enc","wktType","getFlatCoordinates"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/format/WKT.js"],"sourcesContent":["/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon,\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE',\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {position: position, value: value, type: type};\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START,\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(/** @type {number} */ (token.value));\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    );\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */ (token.value);\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      } else {\n        const ctor = GeometryConstructor[geomType];\n        if (!ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n\n        let coordinates;\n\n        if (isEmpty) {\n          if (geomType == 'POINT') {\n            coordinates = [NaN, NaN];\n          } else {\n            coordinates = [];\n          }\n        } else {\n          switch (geomType) {\n            case 'POINT': {\n              coordinates = this.parsePointText_();\n              break;\n            }\n            case 'LINESTRING': {\n              coordinates = this.parseLineStringText_();\n              break;\n            }\n            case 'POLYGON': {\n              coordinates = this.parsePolygonText_();\n              break;\n            }\n            case 'MULTIPOINT': {\n              coordinates = this.parseMultiPointText_();\n              break;\n            }\n            case 'MULTILINESTRING': {\n              coordinates = this.parseMultiLineStringText_();\n              break;\n            }\n            case 'MULTIPOLYGON': {\n              coordinates = this.parseMultiPolygonText_();\n              break;\n            }\n            default:\n              break;\n          }\n        }\n\n        return new ctor(coordinates, this.layout_);\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ =\n      options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */ (\n        geometry\n      ).getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\n    const dimInfo = encodeGeometryLayout(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom)\n    );\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\n\nexport default WKT;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}